{
  "0": {
    "id": "0",
    "title": "Getting Started",
    "content": "Getting Started This document has in mind three different types of users: Developers, Devops, and Reviewers. Developers are interested in making changes to the kbase-ui and related codebases. Tools and procedures",
    "url": "http://localhost:4000/getting-started/README.html",
    "relUrl": "/getting-started/README.html"
  },
  "1": {
    "id": "1",
    "title": "Testing",
    "content": "Testing…",
    "url": "http://localhost:4000/testing/README.html",
    "relUrl": "/testing/README.html"
  },
  "2": {
    "id": "2",
    "title": "Developer Setup",
    "content": "Developer Setup [ to be done ]",
    "url": "http://localhost:4000/getting-started/developer-setup.html",
    "relUrl": "/getting-started/developer-setup.html"
  },
  "3": {
    "id": "3",
    "title": "Image Testing",
    "content": "Testing Images This document will cover testing of already-build images hosted at hub.docker.com. This is an important step in verifying that the current state of deployable kbase-ui images is correct.",
    "url": "http://localhost:4000/testing/image-testing.html",
    "relUrl": "/testing/image-testing.html"
  },
  "4": {
    "id": "4",
    "title": "Integration Testing",
    "content": "Integration Testing Prerequisites To get the most out of this document, you should be famliar with setting up kbase-ui locally for development and/or previewing. See Getting Started. Overview At present, the focus of all testing in kbase-ui is integration testing. It gives the most bang for the buck, exercising not only multiple libraries, but plugins, configuration, and building too. The integration tests require that an instance of kbase-ui be available at at a X.kbase.us host (where X is typically ci, next, appdev, narrative). The tests work by controlling a browser to invoke urls, click on buttons, fill in inputs, and watches to make sure “the right thing happens”. For example, the tests select menu items, conduct searches, log in, and log out. The tests can ensure that the right thing appears when a menu is selected, that the kbase session cookies is available after signin, that a given search resulted in the expected items. Status The integration testing tools are under active development. They do indeed work, and should be conducted prior to any release. Testing Stack The integration testing utilizes Selenium, WebdriverIO, Firefox and Chrome browsers, and our own integration library. Since most user functionality in the UI is provided through plugins, most integration tests reside in plugins as well. Each plugin should contain a testing folder src/plugin/test. This folder contains one or more json or yaml files (yaml preferred). Each of these files defines one or more tests. Each test defines 1 or more steps. All of the details will be spilled in sections below. We call these “integration test scripts”. This is all very new. We may add javascript test scripts later, but for now we have much ground to cover just with simple json scripts. During the kbase-ui build, all of the plugin testing scripts are placed into a single location dev/test/integration-tests/specs/plugins. Also during the build, during the “init” phase specifically, all of the tools required for integration testing are installed locally. kbase-ui generally tries hard to follow the principle, encouraged by npm, to install all tools locally. The only global dependencies are those described in Getting Started. Upon invoking the integration tests, all of the test scripts found in src/plugin/test are run, and the results printed to the console. The integration tests may be run against multiple environments (ci, next, appdev, prod) and browsers (Chrome headless is currently supported) Note that that test configuration can be set up to run tests against Chrome, Firefox, or Safari, but there is no automation for this; it would require tweaking the config file. It is even possible to run the tests against a testing service like Sauce Labs which may test against multiple browser models and versions and on multiple operating systems. Getting Started You can run the integration tests from the basic kbase-ui development environment. Before running the tests, you must: build kbase-ui run the kbase-ui container edit the test config file Okay, that last step is a new one. The integration tests consult a single configuration file for information which cannot be included in the codebase itself. A sample configuration file is placed at dev/test/config.json. This file contains dummy values which describe what you should substitute for them. The configuration file is assembled from sample configs provided by each plugin. Configuration values include core configuration like a user token, the associated username, and associated real name, as well as plugin-specific data required for test running and comparisons. Core configuration token - copy a valid login or dev token into this property username - copy the username associated with this token realname - copy the “realname” (as set in the auth2 record) for this token Plugin configuration Each plugin test suite is configured by a key under the path plugins PLUGIN, where PLUGIN is the plugin name. Running tests In a separate terminal in the kbase-ui root directory, enter the following command: make integration-tests host=ci The host argument is roughly equivalent to the “env” argument used in the build process. At present all this argument does is substitute for the X in X.kbase.us when building the url for the tests scripts. TODO: we need other arguments to control basic test conditions: browser (choose from amongst configured browsers), plugins (pick one or more plugins to test, skip rest). If all goes well, after several tens of seconds you should see a summary of the test results. TODO: the test reporter doesn’t emit progress messages, just a report at the end; fix this NOTE: Due to the variability in test response times, some tests may time out. If this occurs, run the tests one or more times until (and if) they succeed. Common conditions for timeout-based test failures are local machine load (the tests are fairly cpu-intensive), network congestion, kbase service latency, and kbase service maintenance. Files dev/test - placeholder directory for integration test scripts, code, and configuration; this directory is populated when the ui is built; the files are overlaid from the container via a volume mount. test/wdio.conf.integration.js - webdriver io test configuration file src/test - location of script runner files, which are copied into the kbase-ui image and subsequently made available locally through a volume mount at /dev/test. tools/proxy/contents/ssl - empty directory which is populated with test.crt and test.key when make dev-cert is run (and emptyed by make rm-dev-cert). src/client/plugins/PLUGIN/test - location of internal plugin integration test scripts kbase-ui-plugin-PLUGIN/src/plugin/test - location of external plugin integration test scripts. LEFT OFF HERE - stuff below is old and/or unwritten Plugin Testing Script Each plugin should have a directory src/plugin/test which contains one or YAML files containing test scripts. At present the integration test tools support YAML or JSON, but YAML is preferred due the ability to add comments and comment out tests, which are quite handy during testing work. Test Script Format A plugin can have one or more test scripts. Each script should be dedicated to a set of concerns, such as a route. Each plugin should have a test script for each route. A test script may contain one or more test specs. Each spec is composed of one or more test tasks. Any task may cause a test spec failure. The basic structure is: test spec 1 task 1 task 2 task 3 spec 2 task 1 task 2 # Test Script for Dashboard Plugin - description: Dashboard with authentication specs: - description: Dashboard should appear when the route is navigated to tasks: - title: login subtask: login - title: navigate to dashboard navigate: path: dashboard - switchToFrame: selector: - type: iframe value: plugin-iframe wait: 1000 - selector: - type: plugin value: dashboard - type: widget value: narratives-widget - type: slider value: your-narratives wait: 10000 - selector: - type: plugin value: dashboard - type: widget value: narratorials-widget - type: slider value: narratorials wait: 10000 - selector: - type: plugin value: dashboard - type: widget value: shared-narratives-widget - type: slider value: shared-narratives wait: 10000 - selector: - type: plugin value: dashboard - type: widget value: public-narratives-widget - type: slider value: public-narratives wait: 10000 Test Each test script has a single top level node which describes the test. The most important aspect of it is the description field. This field should briefly describe the test. It will be printed in the test results, so should be descriptive enough to distinguish the test amongst many. It should mention the plugin name as well as the overall purpose of the test. description Describes the test script; it should mention the plugin name as well as the overall purpose of the test. baseSelector A selector to be applied to all spec tasks which specify document navigation with a selector. It can be handy to avoid boilerplate in selectors, since a plugin’s tests should primarily operate within the plugin’s dom subtree. selectors A key concept of the integration test scripts is dom navigation. After all, the primary mechanism of integration tests is to poke at the ui and observe how it changes. Both the actions and observations are require that one specify a location with in the DOM – and that location is defined by a DOM selector. In a test script, the selector is represented as an array of objects - each object describes the next DOM node in the selection path. There are two basic ways to specify a path node. The preferred way is to use a special testhook embedded in the plugin’s markup. Testhook support is built into the test tool, and requires less configuration in the test script. Other than testhooks, any attribute and attribute value can be used as a selector. testhook selectors A “testhook” is simply a special data- attribute which has been applied to a node. The format is data-k-b-testhook-type, where type is one of plugin, component, widget, button, element and so forth. The testhook type lets us reduce collisions, and improve readability. The format k-b-testhook is driven by the need to namespace the data- attribute with some form of kbase. In legacy kbase functional html style, this is specified in code as dataKBTesthookType, which is not as strange as data-k-b-testhook-type. Now, one might think that data-kbase-testhook-type is more pleasing on the eyes, but the code form of that is dataKbaseTexthookType, which is error-prone since the official form of kbase is KBase, which would result in data-k-base-testhook-type, which does not seem like an improvement. Here is an example of setting and specifying a testhook: Using legacy kbase functional html style: div({ dataKBTesthookPlugin: &#39;myplugin&#39; }); In the test script: - type: plugin value: myplugin raw selectors The usage of raw selectors is frowned upon, but sometimes necessary. The testhook form is preferred because it is orthogonal to all other usage of DOM node attributes. Classes, for instance, are primarily associated with visual concerns. A developer may be altering classes to improve appearance, and not realize that it is a critical component of a test. By using a dedicated attribute format for testing, tests are much more stable over time and easier to debug, since the same prefix is used for all testhooks. However, at times we don’t have control over markup. For instance, we may be using components which don’t allow custom attributes. In such cases, the test script can use the type raw, and specify any arbitrary attribute name and optional value. E.g. Using legacy kbase functional html style: div({ class: &#39;someclass&#39; }); In the test script: - type: raw name: class value: someclass Spec kbase-ui integration test runner [ describe the test runner scripts ] Integration Test Script Adding Testhooks Testing Scenarios As you develop Before a release In Travis Browsers Firefox some tests curently fail in FF; probably due to webdriver compat Chrome chrome currently works in normal and headless Safari Safari currently works. Don’t know how to run headless yet. A bit finicky though; tends to leave a process behind, sometimes under fail conditions sometimes it just does it, and will refuse to start until the Safari process is killed. First: Open Safari: enable developer menu (Preferences &gt; Advanced &gt; Show Developer menu in menu bar) enable automation (Developer &gt; Allow Remote Automation ) From Terminal: /usr/bin/safaridriver –enable ​",
    "url": "http://localhost:4000/testing/integration-testing.html",
    "relUrl": "/testing/integration-testing.html"
  },
  "5": {
    "id": "5",
    "title": "Developer Prerequisites",
    "content": "Prerequisites The kbase-ui web app is used as a Docker image. For basic usage, including building and running the Docker image, just two applications are required: docker and git. For full-blown development of kbase-ui, these same two dependencies would suffice, but in practice you will need a java development stack. Please see the Development for all the gory details. Basic Development Requirements You will need to ensure that you have a basic set of development tools on your host desktop machine. These tools are available on Mac, Linux, and Windows. app version notes nodejs 6 (LTS) The V8 javascript system, required for building kbase-ui and running tests; we are currently on version 8. npm 6   git * the source revision management tool with integration into github docker * the linux container manager you will use to run kbase-ui dockerize * a utility to make running docker containers more sane make * all build tasks go through make * we haven’t documented any substantial differences between these tools regarding the kbase-ui development process. However, it is best to keep them always at the most recent version by updating your tool stack periodically kbase-ui is built not just on your local development workstation, but int the following places: in Travis CI, as part of the github workflow in the KBase Jenkins instance, as part of the CI deployment in a KBase VM (??) as part of the next/appdev/production deployment process As such, we need to ensure that each part of the build toolchain is consistent in each environment. Thus, even though a different version of the above tools may work for you (and of course no-one is watching you to make sure you aren’t!) please be advised that it is possible that you can introduce dependencies upon a version of a tool which will break in one of the other KBase build environments. nodejs Node and npm are used together to build kbase-ui and to run tests. Node and npm change very frequently, and the number of transitive dependencies involved in the build and test toolchain number in the thousands. Therefore, we must always be cautious when making changes to both the toolchain and dependencies. On the other hand, they are only used for building and testing kbase-ui, and not the runtime operation. git [ to be done ] docker [ to be done ] dockerize dockerize may be installed via go or via a specific binary for linux or macOS: download binary Dockerize is available prebuilt for linux and macOS from the dockerize github repo: export DOCKERIZE_VERSION=6.1 wget https://github.com/jwilder/dockerize/releases/download/$DOCKERIZE_VERSION/dockerize-alpine-linux-amd64-$DOCKERIZE_VERSION.tar.gz tar xvfz dockerize-alpine-linux-amd64-$DOCKERIZE_VERSION.tar.gz sudo mv dockerize /usr/local/bin install via go You may also install it via go. This is especially handy if you are already set up for go, or need to use other go-based programs which are not available through a package manager. install go sudo port install golang update your macOS account profile. E.g. edit ~/.profile vi ~/.profile add the following two lines to the end of the file: export GOPATH=&quot;${HOME}/go&quot; export PATH=$PATH:$(go env GOPATH)/bin and ensure that the go working directory exists mkdir ~/go You will need to spin up a new terminal window to pick up the go settings. Install dockerize: go get github.com/jwilder/dockerize go install github.com/jwilder/dockerize now the dockerize command will be available. make [ to be done] Basic Development Requirements Overview kbase-ui should build and run on any modern system: Mac OS X, Linux, Windows. Procedures for installation of system level packages depends on the system you use, and your toolchain preferences. In this document we provide instructions for installation on platforms in use at KBase using methods that we have employed and work. Installation All environments The following tools are available on all supported platforms (Mac, Windows, Linux). Please consult the installation instructions at the respective web sites: Docker - https://www.docker.com That leaves us with nodejs and git to install through other means. Macintosh There are three common sources for these tools natively on a Mac: Apple xCode Native Mac installation packages Macports Homebrew (see the Linux section for Vagrant on Mac instructions.) The requisite development tools are available as regular Mac packages. This is may be the easiest way to get started. However, if you are going to be installing other Unixy tools, or have one of the following package managers installed, either Macports or Homebrew may be preferable, and are not much more difficult. Package managers also make updating your tools easy, whereas the downloadable packages will need to be periodically updated manually. Apple xCode xCode may be installed from the Apple App Store for free, and is highly recommended for any developer workstation. Not only does it provide some of the required tools, but some macOS developer tools require xCode be installed. xCode includes both git and make, which are required for building kbase-ui, as well as a compilers which may be required to install other developer tools via installers from macports, npm, and the like. Although xCode includes git, make and other developer tools, you may also opt to install these or similar (e.g. gmake) tools separately. Native Packages Installation of native Mac packages should put you in good stead. Just follow the links and instructions therein. 1) Git Git may be installed directly from the git organization: http://git-scm.com/download/mac Git may also be installed as a command line tool component of Apple xCode, or independently via a Mac package manager like macports or brew, if you favor those. You should simply install the most recent version available 2) Nodejs nodejs may be installed from the canonical home: https://nodejs.org As of this time, please use version 8 of NodeJS. We try to stay on the most recent LTS release, but the most important constraint is that we are using the same major version across all environments - local dev, travis, CI and next/appdev/prod. 3) npm global packages It is no longer recommended to install the global version of npm-based development tools. Rather, they run out of the local kbase-ui repo. The local repo always installs these tools, since they are used by the build and testing tools. For convenience, you may run . tools/devtools.sh from a terminal window located at the kbase-ui repo directory to put the node executable directory into the current path. Note: yarn? Yes, we may be switching to yarn in the near future. Macports 1) Install Apple xCode As mentioned above, you should have already installed xCode — xCode is required by macports. 2) Install macports Download and follow the instructions at https://www.macports.org/install.php. Macports will install its own binary path (/opt/local/bin:/opt/local/sbin/) ahead of the path used by xCode (/usr/bin). You can change that in ~/.profile if you wish. 2) Use the terminal to install the dependencies using Macports open Terminal and issue the following commands: sudo port install nodejs6 npm5 git Note that the version of nodejs is important. We try very hard to use the same version of nodejs in local development as KBase uses in build/deployment environments and as the Travis configuration uses. There are major changes between nodejs releases. Although a newer nodejs will be probably be able to run code written for an older version, the converse is not necessarily true, and it is certainly easy to start using features enabled by a newer node version if it is available. There may also be subtle differences in the building of dependencies through npm. In general we try to stay on the most recent Long Term Support (LTS) of any dependency, but sometimes it takes us a while to have time to coordinate the concurrent update of all of the places they are used. Note: Although xCode installs git, the one available through macports is probably more up-to-date. Homebrew to be done Windows to be done Linux Ubuntu to be done Index - README - Release Notes - KBase",
    "url": "http://localhost:4000/getting-started/local-dev-prerequisites.html",
    "relUrl": "/getting-started/local-dev-prerequisites.html"
  },
  "6": {
    "id": "6",
    "title": "KBase UI",
    "content": "An aside: How plugins are built into kbase-ui In the kbase-ui build configuration, there exists a configuration file listing all of the plugins to be built into the kbase-ui web app. This configuration file specifies the plugin name, the location and the version. The entry will look like this: - name: PLUGINNAME globalName: kbase-ui-plugin-PLUGINNAME version: 1.2.3 cwd: src/plugin source: bower: {} During the kbase-ui build process, the build tool uses the bower package manager to locate and download the correct version of the plugin source from github and install it locally. The build tool then copies the plugin’s src/plugin directory into kbase-ui’s build/build/client/modules/plugins directory, and uses the plugin’s src/plugin/config.yml file to integrate plugin components into the ui. Now, you may be able to see that one way to develop plugins is to simply update the plugin source, push it up into the repo, update the repo version, and rebuild kbase-ui. That is the short version of the steps necessary to integrate a plugin change! Although these steps are necessary for a well-managed system, it would be a slow way to incrementally develop a plugin (although you can imagine a set of tools to automate it.) So, at develop-time, an alternative method is used. Since during the kbase-ui build process the plugin src/plugin directory is simply copied, whole-cloth, into the kbase-ui build source tree, we can simply alter the kbase-ui build to point to the plugin’s local src/plugin/module rather than the installed one. In old development workflows, the installed plugin would be removed and the local development directory linked into the build. In the current docker-based workflow, we use the docker run mount options to perform a similar function. Fortunately this is wrapped within the ‘run-image.sh’ tool.",
    "url": "http://localhost:4000/notes/notes.html",
    "relUrl": "/notes/notes.html"
  },
  "7": {
    "id": "7",
    "title": "Prerequisites",
    "content": "Prerequisites The kbase-ui is a web app, composed of html, javascript, css, data files, image files, and many other assets. As a web app it can be used behind just about any type of web server. In order to use the web app, it must operate on a supported KBase host. Practically this means that it should operate behind a proxy server which itself operates on the KBase host. (These hosts are https://X.kbase.host, where X is ci, next, appdev, and narrative). In deployments, KBase uses an nginx proxy front end and rancher to orchestrate kbase-ui and other services which operate to form a connected set of services. For basic kbase-ui usage and local development, a special docker-compose configuration provides a proxy container as well as kbase-ui container to simulate this service configuration. The requirements for them are simple: make, git, and docker. For certain development tasks, or to run specific phases of the development process, additional tools are required, but nothing out of the ordinary Javascript development toolkit. These are described in the developer documentation Basic Requirements You will need to ensure that you have a basic set of the following tools on your host desktop machine. These tools are available on Mac, Linux, and Windows. app version notes docker 18.x.x the linux container manager you will use to build and run kbase-ui git * the source revision management tool with integration into github make &gt;= 3.8 any relatively recent make should work node &gt;= 8 any recent version should work * we haven’t documented any substantial differences between these tools regarding the kbase-ui development process. However, it is best to keep them always at the most recent version by updating your tool stack periodically. The reason for the relaxed version requirements is that kbase-ui is built inside of a Docker build process, using specific software package versions which are installed into a Docker image. The software requirements specified above are for local development tools only. macOS Apple xCode xCode may be installed from the Apple App Store for free, and is highly recommended for any developer workstation. Not only does it provide some of the required tools, but some macOS developer tools require xCode be installed. xCode includes both git and make, which are required for building kbase-ui, as well as a compilers which may be required to install other developer tools via installers from macports, npm, and the like. MacPorts MacPorts is a package manager for macOS. It differs from another popular macOS package manager, HomeBrew, in that it requires root access (sudo) to install packages. Download and follow the instructions at https://www.macports.org/install.php. Macports will install its own binary path (/opt/local/bin:/opt/local/sbin/) ahead of the path used by xCode (/usr/bin). You can change that in ~/.profile if you wish. You’ll need to open a new Terminal window in order to pick up the path changes. xCode may be required by Macports to install certain packages (some are distributed as binary, some need to be compiled.) brew [ to be done ] make The ubiquitous and venerable “make” program is used to automate just about all of the tasks for development and deployment. MacOS The make program is installed with xCode, and that version seems adequate. Note that the make installed with xCode is GNU make, which is good, because it is compatible with Linux. This may be true of xCode tools, but generally macOS distributes BSD versions of other unixy tools like sed and grep. Windows [ to be done ] Linux [ to be done ] git git is used to fetch kbase-ui and any other repos that may be involved in a given development effort. Of course, if you are making source code changes it is a critical tool in the development process. MacOS On MacOS, git is available through xCode, macports, brew, and an installer from git. Apple xCode Although xCode includes git, make and other developer tools, you may also opt to install these or similar (e.g. gmake) tools separately. Native Package from git Installation of native Mac packages should put you in good stead. Just follow the links below and instructions therein. http://git-scm.com/download/mac Macports Open Terminal and issue the following commands: sudo port install git Note: Although xCode installs git, the one available through macports is probably more up-to-date. Linux As a Linux user, you should be familiar with the package management tools for the distribution you use. Without a version constraint, you should just install the most recent version available. E.g. for Ubuntu sudo apt-get install git Windows [ to be done ] docker Distribution of Docker changes from time to time. Currently it is best to consule the Docker Store, which should list a distribution for macOS, Windows, and various Linux distributions. That failing, just explore Docker.",
    "url": "http://localhost:4000/getting-started/prerequisites.html",
    "relUrl": "/getting-started/prerequisites.html"
  },
  "8": {
    "id": "8",
    "title": "Quick Start",
    "content": "Quick Start This guide should allow you to run kbase-ui on your host system. For more advanced developer or deployment scenarios, consult … Prerequisites Read the prerequisites guide to ensure your host machine is up to snuff. macOS A kbase-ui project requires a dedicated directory, into which you will clone the repos you are working with. open a terminal into this folder, either the built-in Terminal program, iTerm, or your terminal app of choice. Clone the kbase/kbase-ui repo into this folder: git clone -b develop https://github.com/kbase/kbase-ui Create and launch the kbase-ui image: Due to recent changes in the docker configuration, the make task has been replaced with less automated process. The following command line will build and launch the local development version of kbase-ui: make dev-start Since that container is now running in the terminal, you’ll need to open a new terminal window. Point ci.kbase.us to your local computer: Edit sudo vi /etc/hosts adding the line 127.0.0.1 ci.kbase.us at the end of the file, then save it [Shift][Z][Z] Open a browser to https://ci.kbase.us Since the proxy uses a self-signed certificate to support https, your browser will likely complain. Just suffer through the prompts to allow the connection to proceed.1 You should now see kbase-ui 😊 When done, you can simply press [Control][C] in the original terminal window to stop the containers.2 If you won’t be conducting further builds for this instance, you’ll want to clear out the intermediate build image:3 make dev-clean Linux [ to do ] Windows 10 [ to do ] Next Steps Getting started with development -– If your browser hangs when attempting to connect, you should have better luck using the private mode of your browser. Both Safari and Chrome work fine in private mode with self-signed certs, Firefox will still hang. &#8617; Currently docker-compose does not always clean up after itself when using [Control][C] to stop it; see this github issue. &#8617; This also removes the Docker network “kbase-dev” created during image-building process. &#8617;",
    "url": "http://localhost:4000/getting-started/quick-start-for-developers.html",
    "relUrl": "/getting-started/quick-start-for-developers.html"
  },
  "9": {
    "id": "9",
    "title": "Recipes",
    "content": "Test Recipes Unit Testing make unit-tests Integration Testing make integration-tests host=HOST where HOST is one of ci, next, appdev, narrative. TODO: instead of host, use env, and have the host looked up in the deploy configs. TODO: better yet, have an uber-integration test which reads all the configs, and runs the tests for each environment.",
    "url": "http://localhost:4000/testing/recipes.html",
    "relUrl": "/testing/recipes.html"
  },
  "10": {
    "id": "10",
    "title": "Unit Testing",
    "content": "Unit Testing",
    "url": "http://localhost:4000/testing/unit-testing.html",
    "relUrl": "/testing/unit-testing.html"
  },
  "11": {
    "id": "11",
    "title": "The KBase User Interface",
    "content": "The KBase User Interface kbase-ui is a web app providing access to many user services, including: signup, signin, signout account management narrative browsing and searching data search app catalog and developer tools This document provides a guide to developing and deploying with kbase-ui. - For user documentation, please visit the KBase Documentation site. Notes Documentation is under revision - chapters prefixed with a pickaxe ⛏ are under revision, out of date and probably inaccurate. First Steps Prerequisites Quick Start for Developers Design Architecture Dependencies Process Coding Standards Testing Configuration Plugins About Developing a Plugin Creating a New Plugin Deployment Overview Configuration Disabling Menus Testing Overview Integration Development Scenarios Developing Plugins Developing alongside the Narrative Special Topics Adding a plugin or library to bower Create Plugin From Scratch Testing a Pull Request Token Export/Import Error Handling Index - README - Release Notes - KBase",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  }
  
}
